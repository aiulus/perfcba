"""Exploitation policies aware of discovered parent sets."""

from __future__ import annotations

import math
from dataclasses import dataclass
from typing import Dict, List, Optional, Sequence, Tuple

import numpy as np

from .causal_envs import (
    CausalBanditInstance,
    InterventionArm,
    InterventionSpace,
)


ArmID = Tuple[Tuple[int, ...], Tuple[int, ...]]


@dataclass
class ArmInfo:
    """Metadata for an intervention arm."""

    arm: InterventionArm
    true_mean: float

    @property
    def id(self) -> ArmID:
        return (self.arm.variables, self.arm.values)


class ParentAwareUCB:
    """
    Simple UCB1 controller operating on a dynamically changing arm set.
    """

    def __init__(self) -> None:
        self._arms: List[ArmInfo] = []
        self._arm_ids: List[ArmID] = []
        self._stats: Dict[ArmID, List[float]] = {}
        self._total_pulls = 0

    def set_arms(self, arm_infos: Sequence[ArmInfo], *, warm_start_from: Optional["ParentAwareUCB"] = None) -> None:
        old_stats: Dict[ArmID, Tuple[int, float]] = {}
        if warm_start_from is not None:
            old_stats = {
                arm_id: (int(stats[0]), float(stats[1]))
                for arm_id, stats in warm_start_from._stats.items()
            }

        self._arms = list(arm_infos)
        self._arm_ids = [info.id for info in self._arms]
        self._stats = {}
        self._total_pulls = 0

        for arm_id in self._arm_ids:
            pulls, reward_sum = old_stats.get(arm_id, (0, 0.0))
            self._stats[arm_id] = [pulls, reward_sum]
            self._total_pulls += pulls

    def select(self, rng: np.random.Generator) -> Tuple[int, InterventionArm]:
        if not self._arms:
            raise RuntimeError("No arms available for exploitation.")
        for idx, arm_id in enumerate(self._arm_ids):
            pulls = int(self._stats[arm_id][0])
            if pulls == 0:
                return idx, self._arms[idx].arm

        self._total_pulls += 1
        best_idx = 0
        best_score = float("-inf")
        log_term = math.log(self._total_pulls + 1)
        for idx, arm_id in enumerate(self._arm_ids):
            pulls, reward_sum = self._stats[arm_id]
            mean = reward_sum / max(1, pulls)
            bonus = math.sqrt(2.0 * log_term / max(1, pulls))
            score = mean + bonus
            if score > best_score:
                best_score = score
                best_idx = idx
        return best_idx, self._arms[best_idx].arm

    def observe(self, arm_index: int, reward: float) -> None:
        if not (0 <= arm_index < len(self._arm_ids)):
            raise IndexError("arm_index out of range")
        arm_id = self._arm_ids[arm_index]
        self._stats[arm_id][0] += 1
        self._stats[arm_id][1] += reward

    def arms(self) -> Sequence[ArmInfo]:
        return list(self._arms)


class ArmBuilder:
    """
    Generates intervention arms given the discovered parent set.
    """

    def __init__(
        self,
        instance: CausalBanditInstance,
        space: InterventionSpace,
        *,
        subset_size: Optional[int] = None,
        mc_samples: int = 2048,
    ) -> None:
        self.instance = instance
        self.space = space
        self.subset_size = subset_size
        self.mc_samples = mc_samples

    def _default_subset(self, rng: np.random.Generator) -> Sequence[ArmInfo]:
        if self.subset_size is None:
            arms = list(self.space.arms())
        else:
            arms = self.space.random_subset(self.subset_size, rng, replace=False)
        rng_local = np.random.default_rng(rng.integers(2**32 - 1))
        return [
            ArmInfo(arm=a, true_mean=self.instance.estimate_arm_mean(a, rng_local, self.mc_samples))
            for a in arms
        ]

    def _parent_arms(
        self,
        parents: Sequence[int],
        rng: np.random.Generator,
    ) -> Sequence[ArmInfo]:
        ell = self.instance.config.ell
        rng_local = np.random.default_rng(rng.integers(2**32 - 1))
        arms: List[ArmInfo] = []
        for values in np.ndindex(*(ell for _ in parents)):
            arm = InterventionArm(tuple(parents), tuple(values))
            mean = self.instance.estimate_arm_mean(arm, rng_local, self.mc_samples)
            arms.append(ArmInfo(arm=arm, true_mean=mean))
        return arms

    def build(
        self,
        parent_set: Sequence[int],
        rng: np.random.Generator,
    ) -> Tuple[Sequence[ArmInfo], Dict[ArmID, float]]:
        if not parent_set:
            arms = self._default_subset(rng)
        elif len(parent_set) > self.instance.config.m:
            arms = self._parent_arms(parent_set[: self.instance.config.m], rng)
        else:
            arms = self._parent_arms(parent_set, rng)
        mean_lookup = {info.id: info.true_mean for info in arms}
        return arms, mean_lookup
