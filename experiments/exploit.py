"""Exploitation policies aware of discovered parent sets."""

from __future__ import annotations

import math
from dataclasses import dataclass
from typing import Dict, List, Optional, Sequence, Tuple

import numpy as np

from .causal_envs import (
    CausalBanditInstance,
    InterventionArm,
    InterventionSpace,
)


@dataclass
class ArmInfo:
    """Metadata for an intervention arm."""

    arm: InterventionArm
    true_mean: float


class ParentAwareUCB:
    """
    Simple UCB1 controller operating on a dynamically changing arm set.
    """

    def __init__(self) -> None:
        self._arms: List[ArmInfo] = []
        self._counts: List[int] = []
        self._sums: List[float] = []
        self._total_pulls = 0

    def set_arms(self, arm_infos: Sequence[ArmInfo]) -> None:
        self._arms = list(arm_infos)
        self._counts = [0 for _ in self._arms]
        self._sums = [0.0 for _ in self._arms]
        self._total_pulls = 0

    def select(self, rng: np.random.Generator) -> Tuple[int, InterventionArm]:
        if not self._arms:
            raise RuntimeError("No arms available for exploitation.")
        for idx, count in enumerate(self._counts):
            if count == 0:
                return idx, self._arms[idx].arm
        self._total_pulls += 1
        scores = []
        for idx, info in enumerate(self._arms):
            mean = self._sums[idx] / max(1, self._counts[idx])
            bonus = math.sqrt(2.0 * math.log(self._total_pulls + 1) / self._counts[idx])
            scores.append((mean + bonus, idx))
        scores.sort(reverse=True)
        best_idx = scores[0][1]
        return best_idx, self._arms[best_idx].arm

    def observe(self, arm_index: int, reward: float) -> None:
        self._counts[arm_index] += 1
        self._sums[arm_index] += reward

    def arms(self) -> Sequence[ArmInfo]:
        return list(self._arms)


class ArmBuilder:
    """
    Generates intervention arms given the discovered parent set.
    """

    def __init__(
        self,
        instance: CausalBanditInstance,
        space: InterventionSpace,
        *,
        subset_size: Optional[int] = None,
        mc_samples: int = 2048,
    ) -> None:
        self.instance = instance
        self.space = space
        self.subset_size = subset_size
        self.mc_samples = mc_samples

    def _default_subset(self, rng: np.random.Generator) -> Sequence[ArmInfo]:
        if self.subset_size is None:
            arms = list(self.space.arms())
        else:
            arms = self.space.random_subset(self.subset_size, rng, replace=False)
        rng_local = np.random.default_rng(rng.integers(2**32 - 1))
        return [
            ArmInfo(arm=a, true_mean=self.instance.estimate_arm_mean(a, rng_local, self.mc_samples))
            for a in arms
        ]

    def _parent_arms(
        self,
        parents: Sequence[int],
        rng: np.random.Generator,
    ) -> Sequence[ArmInfo]:
        ell = self.instance.config.ell
        rng_local = np.random.default_rng(rng.integers(2**32 - 1))
        arms: List[ArmInfo] = []
        for values in np.ndindex(*(ell for _ in parents)):
            arm = InterventionArm(tuple(parents), tuple(values))
            mean = self.instance.estimate_arm_mean(arm, rng_local, self.mc_samples)
            arms.append(ArmInfo(arm=arm, true_mean=mean))
        return arms

    def build(
        self,
        parent_set: Sequence[int],
        rng: np.random.Generator,
    ) -> Sequence[ArmInfo]:
        if not parent_set:
            return self._default_subset(rng)
        if len(parent_set) > self.instance.config.m:
            # fall back to the first m parents
            return self._parent_arms(parent_set[: self.instance.config.m], rng)
        return self._parent_arms(parent_set, rng)
