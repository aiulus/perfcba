"""Exploitation policies aware of discovered parent sets."""

from __future__ import annotations

import math
from dataclasses import dataclass
from itertools import combinations
from typing import Dict, List, Optional, Sequence, Tuple

import numpy as np

from .causal_envs import (
    CausalBanditInstance,
    InterventionArm,
    InterventionSpace,
)


ArmID = Tuple[Tuple[int, ...], Tuple[int, ...]]


@dataclass
class ArmInfo:
    """Metadata for an intervention arm."""

    arm: InterventionArm
    true_mean: float

    @property
    def id(self) -> ArmID:
        return (self.arm.variables, self.arm.values)


class ParentAwareUCB:
    """
    Simple UCB1 controller operating on a dynamically changing arm set.
    """

    def __init__(self) -> None:
        self._arms: List[ArmInfo] = []
        self._arm_ids: List[ArmID] = []
        self._stats: Dict[ArmID, List[float]] = {}
        self._total_pulls = 0

    def set_arms(self, arm_infos: Sequence[ArmInfo], *, warm_start_from: Optional["ParentAwareUCB"] = None) -> None:
        old_stats: Dict[ArmID, Tuple[int, float]] = {}
        if warm_start_from is not None:
            old_stats = {
                arm_id: (int(stats[0]), float(stats[1]))
                for arm_id, stats in warm_start_from._stats.items()
            }

        self._arms = list(arm_infos)
        self._arm_ids = [info.id for info in self._arms]
        self._stats = {}
        self._total_pulls = 0

        for arm_id in self._arm_ids:
            pulls, reward_sum = old_stats.get(arm_id, (0, 0.0))
            self._stats[arm_id] = [pulls, reward_sum]
            self._total_pulls += pulls

    def select(self, rng: np.random.Generator) -> Tuple[int, InterventionArm]:
        if not self._arms:
            raise RuntimeError("No arms available for exploitation.")
        zero_pull_indices = [idx for idx, arm_id in enumerate(self._arm_ids) if int(self._stats[arm_id][0]) == 0]
        if zero_pull_indices:
            choice = int(rng.integers(len(zero_pull_indices)))
            idx = zero_pull_indices[choice]
            return idx, self._arms[idx].arm

        best_idx = 0
        best_score = float("-inf")
        total_pulls = max(1, self._total_pulls)
        log_term = math.log(total_pulls + 1)
        for idx, arm_id in enumerate(self._arm_ids):
            pulls, reward_sum = self._stats[arm_id]
            mean = reward_sum / max(1, pulls)
            bonus = math.sqrt(2.0 * log_term / max(1, pulls))
            score = mean + bonus
            if score > best_score:
                best_score = score
                best_idx = idx
        return best_idx, self._arms[best_idx].arm

    def observe(self, arm_index: int, reward: float) -> None:
        if not (0 <= arm_index < len(self._arm_ids)):
            raise IndexError("arm_index out of range")
        arm_id = self._arm_ids[arm_index]
        self._stats[arm_id][0] += 1
        self._stats[arm_id][1] += reward
        self._total_pulls += 1

    def arms(self) -> Sequence[ArmInfo]:
        return list(self._arms)


@dataclass(frozen=True)
class HybridArmConfig:
    """
    Controls how ArmBuilder augments partial parent sets with hybrid interventions.

    Attributes:
        enabled: If True and 0 < |parents| < m, include arms that intervene on the
            discovered parents plus additional covariates up to the arity cap.
        max_fillers: Optional cap on the number of filler-variable combinations to
            consider when generating hybrid arms.  When None, all combinations are
            used (may be expensive for large n).
        max_hybrid_arms: Optional cap on the total number of hybrid assignments
            materialized (per parent_set).  Useful for keeping Monte Carlo costs
            bounded in high-arity regimes.
    """

    enabled: bool = False
    max_fillers: Optional[int] = None
    max_hybrid_arms: Optional[int] = None


class ArmBuilder:
    """
    Generates intervention arms given the discovered parent set.
    """

    def __init__(
        self,
        instance: CausalBanditInstance,
        space: InterventionSpace,
        *,
        subset_size: Optional[int] = None,
        mc_samples: int = 2048,
        hybrid_config: Optional[HybridArmConfig] = None,
    ) -> None:
        self.instance = instance
        self.space = space
        self.subset_size = subset_size
        self.mc_samples = mc_samples
        self.hybrid_config = hybrid_config or HybridArmConfig()

    def _default_subset(self, rng: np.random.Generator) -> Sequence[ArmInfo]:
        if self.subset_size is None:
            arms = list(self.space.arms())
        else:
            arms = self.space.random_subset(self.subset_size, rng, replace=False)
        rng_local = np.random.default_rng(rng.integers(2**32 - 1))
        return [
            ArmInfo(arm=a, true_mean=self.instance.estimate_arm_mean(a, rng_local, self.mc_samples))
            for a in arms
        ]

    def _assignment_arms(
        self,
        variables: Sequence[int],
        rng_local: np.random.Generator,
    ) -> Sequence[ArmInfo]:
        if not variables:
            return []
        ell = self.instance.config.ell
        arms: List[ArmInfo] = []
        for values in np.ndindex(*(ell for _ in variables)):
            arm = InterventionArm(tuple(variables), tuple(values))
            mean = self.instance.estimate_arm_mean(arm, rng_local, self.mc_samples)
            arms.append(ArmInfo(arm=arm, true_mean=mean))
        return arms

    def _parent_arms(
        self,
        parents: Sequence[int],
        rng: np.random.Generator,
    ) -> Sequence[ArmInfo]:
        if not parents:
            return []
        rng_local = np.random.default_rng(rng.integers(2**32 - 1))
        return self._assignment_arms(tuple(parents), rng_local)

    def _parent_subset_arms(
        self,
        parents: Sequence[int],
        rng: np.random.Generator,
    ) -> Sequence[ArmInfo]:
        m = self.instance.config.m
        if len(parents) <= m:
            return self._parent_arms(parents, rng)
        rng_local = np.random.default_rng(rng.integers(2**32 - 1))
        arms: Dict[ArmID, ArmInfo] = {}
        for subset in combinations(parents, m):
            for info in self._assignment_arms(subset, rng_local):
                arms[info.id] = info
        return list(arms.values())

    def _reservoir_sample_combinations(
        self,
        items: Sequence[int],
        choose: int,
        max_samples: Optional[int],
        rng: np.random.Generator,
    ) -> List[Tuple[int, ...]]:
        if choose <= 0:
            return [tuple()]
        iterator = combinations(items, choose)
        if max_samples is None:
            return [tuple(combo) for combo in iterator]
        reservoir: List[Tuple[int, ...]] = []
        for idx, combo in enumerate(iterator, start=1):
            if len(reservoir) < max_samples:
                reservoir.append(tuple(combo))
                continue
            j = int(rng.integers(idx))
            if j < max_samples:
                reservoir[j] = tuple(combo)
        return reservoir

    def _hybrid_parent_arms(
        self,
        parents: Sequence[int],
        rng: np.random.Generator,
    ) -> Sequence[ArmInfo]:
        cfg = self.hybrid_config
        if not cfg.enabled or not parents:
            return []
        m = self.instance.config.m
        if m <= 0:
            return []
        if len(parents) >= m:
            return []
        extra = m - len(parents)
        candidates = [idx for idx in range(self.instance.config.n) if idx not in parents]
        if extra > len(candidates):
            return []
        rng_local = np.random.default_rng(rng.integers(2**32 - 1))
        filler_sets = self._reservoir_sample_combinations(candidates, extra, cfg.max_fillers, rng_local)
        ell = self.instance.config.ell
        hybrid_infos: Dict[ArmID, ArmInfo] = {}
        for filler in filler_sets:
            variables = tuple(sorted((*parents, *filler)))
            for values in np.ndindex(*(ell for _ in variables)):
                arm = InterventionArm(tuple(variables), tuple(values))
                mean = self.instance.estimate_arm_mean(arm, rng_local, self.mc_samples)
                hybrid_infos[(arm.variables, arm.values)] = ArmInfo(arm=arm, true_mean=mean)
                if cfg.max_hybrid_arms is not None and len(hybrid_infos) >= cfg.max_hybrid_arms:
                    return list(hybrid_infos.values())
        return list(hybrid_infos.values())

    def build(
        self,
        parent_set: Sequence[int],
        rng: np.random.Generator,
    ) -> Tuple[Sequence[ArmInfo], Dict[ArmID, float]]:
        if not parent_set:
            arms = self._default_subset(rng)
            mean_lookup = {info.id: info.true_mean for info in arms}
            return arms, mean_lookup

        parent_set = tuple(sorted(parent_set))
        arm_infos: Dict[ArmID, ArmInfo] = {}
        for info in self._parent_subset_arms(parent_set, rng):
            arm_infos[info.id] = info
        for info in self._hybrid_parent_arms(parent_set, rng):
            arm_infos.setdefault(info.id, info)

        arms = list(arm_infos.values())
        mean_lookup = {info.id: info.true_mean for info in arms}
        return arms, mean_lookup
